per editor:
    tutti gli stili non default SONO CUSTOM, e come tali saranno salvati (se non con un nome esplicito con un id generato casualmente) nel json di elementi custom.



requirement individuati, temporanei:
    item:
        - gli item esistono
        - l'acquisizione di un item È il passaggio per un nodo
        - per memorizzare la verifica di un item, si usa il tag "condition", che è UN ARRAY DI NODI per cui si dovrebbe passare (or sui nodi)
        - è possibile che non faremo in nessun modo così e useremo uno storage locale e tanti saluti
    layout domanda:
        - header/footer: possono contenere più o meno gli stessi componenti (e.g. timer, informazioni di paginazione o contesto ecc...), NO elementi legati al contenuto specifico
        - content:
            contiene IL WIDGET della domanda e le relative prop (le possibili risposte ecc..)
    paths:
        - i possibili valori per path sono:
            1. una label di un altro nodo
            2. un oggetto contenente una condizione:
                { condition: "SOME_LABEL", paths: { TRUE: "SOME_LABEL_TRUE", FALSE: "SOME_LABEL_FALSE" } }



ogni nodo deve valutare gli eventi che lo coinvolgono e, quando ha finito, chiamare una funzione "proceed" che sposti il nodo corrente a un altro. Per esempio:

es. nodo Choice:
_________________________________________________
|nome del nodo                                   |
|descrizione                                     |
|risposte:                                       |
|    ___________________    ____                 |
|    |giovanni -> nodo 3 | | -> |                |
|    |___________________| |____|                |
|    |antonio -> nodo 4  |                       |
|    |___________________|                       |
|    |roberto -> nodo 2  |                       |
|    |___________________|                       |
|    ______                                      |
|    |  +  |                                     |
|    |_____|                                     |
|    ________   ____                             |
|    |timeout| | -> |                            |
|    |_______| |____|                            |
|________________________________________________|

    multiple choice/storia:
        componente:
            alla scelta di una risposta, la risposta viene valutata e chiamo proceed(risposta) o proceed(risposta.conseguenza)
        editor:
            per n risposte, ci sono n+1 eventi: la scelta di ogni risposta e il timeout. tutte modificano il nodo corrente. durante l'editing, a ogni risposta sarà collegato un arco che sposta il nodo corrente, più un quadratino aggiuntivo per il timeout.
        player:
            solo n risposte compaiono. al timeout (che può non succedere mai) il giocatore sarà automaticamente spostato
        valutatore:
            la visualizzazione è come quella dell'editor, ma centrata su quel nodo. ci penseremo poi dopo
    timer:
        componente:
            al timeout, viene chiamata proceed(timeout.conseguenza). cleanup necessario per non attivare il timeout quando non sarà più renderizzato
        editor:
            un quadratino chiede cosa fare all'evento, PER ORA SOLO SPOSTARE IL NODO
        player:
            un timer viene visualizzato
        valutatore:
            come il player, ma può vedere anche la conseguenza
    camera:
        componente:
            pulsante per scattare la foto, e confermare l'invio. alla conferma dell'invio, o la conclusione dell'invio, viene chiamata proceed(sent.conseguenza). possibile timeout
        editor:
            boh
        player:
            boh
        valutatore:
            boh
    


tipi:
    individuale
    piccolo gruppo (2-5)
    classe (in gruppi paralleli in competizione)

struttura:
    individuale -> 15-18 -> alone in space (flashlight? che figata che sarebbe)
    piccolo gruppo/classe -> 11-14 -> 
        viaggiatore nel tempo ai tempi dell'antica roma (es: come si chiama il vestito dei senatori romani, cosa vuol dire in italiano "veni", che scarpe usavano...)
    classe/piccolo gruppo -> 8-11 -> la pimpa o una storia di un omino di carta (2-3 dimensioni, introduzione alla dimensionalità) ("giorgino cercava la sua ruota, ma non riconosceva più nulla da quando si era alzato dal foglio. Quale di questi era la sua ruota?")

Mentalità realizzativa: sapere dove ci si trova, in quale posizione, muoversi in un ambiente, manipolare oggetti:
    - oggetti e qualità:
        colore, consistenza, dimensione (base)
    - numeri:
        contare oggetti, minime abilità aritmetiche, contare passi? suoni?
    - orientarsi:
        cercare una certa stanza, oppure riconoscere in quale stanza ci si trova

Mentalità iconica: riconoscere, confrontare, configurare, concretizzare:
    - oggetti e qualità:
        somiglianza (quale colore è più simile a questo, quale oggetto è il più vicino concettualmente, quale elemento non appartiene)
        trovare una rappresentazione all'interno di un'immagine
    - numeri:
        conteggio + aritmetica

Mentalità simbolica: astrarre, concatenare catene di passi logici, dedurre:
    - quesiti (di matematica, logica, *conoscenze di base di materie varie* i dont like)
    - indovinelli

fasce d'età:
    7-10 (realizzative-iconiche, no simboliche)
    11-14(iconiche-simboliche, poco realizzativo)
    15-18(molte simboliche)

Cose da ricordarsi (mettz):
    - possibile aggiungere una schermata iniziale pre-storia con informazioni di carattere generale o suggerimenti per godere a pieno dell'esperienza (e.g. (1))
player wakes

START[StoryNode]:
    (1) conditional start: depending on locale, it asks to start when it's dark, and to turn off all lights except the room you're starting in. this can be bypassed.
    big description: amnesia, basic spatial explanation (what you can "see"), current objective: find stuff out.
    paths:
        [3 "radio button"]
        READ_TABLET: look into the tablet
        SEARCH: look around
        LEAVE_LIGHT_ON: get out

LEAVE_LIGHT_ON[StoryNode]:
    someone sees you, they shoot you, you're dead. back to last checkpoint START

READ_TABLET[StoryNode]:
    history: find out you're on a spaceship, some lore or whatever. useful info
    tablet asks you if you want to set a password
    paths:
        SET_PASS
        IGNORE_PASS

IGNORE_PASS[StoryNode]:
    you don't set any password. after all, who's going to look into your tablet? you have it on you, right?
    paths:
        KEEP_READING:  --
        SEARCH: look around
        LEAVE: get out. depending on light status, LEAVE_LIGHT_ON or LEAVE_LIGHT_OFF

SET_PASS[QuestNode]:
    asks for input, only numbers
    paths:
        success:
            ENABLE_PASS
        failure:
            IGNORE_PASS: you press cancel and go back to previous screen

ENABLE_PASS:
    pass enabled!
    self.pass = true
    paths:
        KEEP_READING

SEARCH[StoryNode]:
    brief history: some clues as to where you are. an electrical panel
    paths:
        TURN_OFF_ALL
        LEAVE

TURN_OFF_ALL:
    cifrario o che ne so. something to solve to turn off the light
    paths:
        solved: TURNED_OFF_LIGHTS
        wrong: WRONG_OFF_LIGHTS

TURNED_OFF_LIGHTS;
    Lights were turned off! what should you do now?
    paths:
        READ_TABLET
        LEAVE_LIGHT_OFF

WRONG_OFF_LIGHTS:
    wrong answer... what should you do now?
    paths:
        TURN_OFF_ALL
        LEAVE_LIGHT_ON

KEEP_READING[]:
    you realize your phone has a flashlight function, but it asks to verify you're human and to solve an unreasonably difficult captcha
    paths:
        solved: self.light = enabled;
            TURN_ON_LIGHT
        wrong: choice:
            NO_TURN_ON_LIGHT

TURN_ON_LIGHT:
    you turned on the light!
    paths:
        STAY_ON_PHONE
        LEAVE_LIGHT_OFF

STAY_ON_PHONE:
    someone walks in and shoots you. you're dead
    paths: last checkpoint(START)

NO_TURN_ON_LIGHT:
    you didn't quite solve it...
    paths:
        TRY AGAIN -> (KEEP_READING)
        LEAVE_LIGHT_OFF

LEAVE_LIGHT_OFF:
    you slowly open the door. explanation: small room, glowing thing in the center. you feel drawn to it. once you touch it, it feels as if a rake is going through your mind
    CHECKPOINT1

CHECKPOINT1:
    something about inhabiting a new body or whatever. has to be the same text everytime you die and respawn. maybe something about consciousness or something
    paths:
        ROOM2

ROOM2:
    maybe a little description. you have to hide. where?
    paths:
        UNDER_TABLE
        IN_CLOSET

UNDER_TABLE
    oh no you died the human found you
    CHECKPOINT1

IN_CLOSET:
    timed quest coming up
    self.inclosettime = 0
    if self.light:
        OPEN_CLOSET
    else:
        SOLVE_TIMED_CLOSET

SOLVE_TIMED_CLOSET:
    timed quest
    paths:
        solved: OPEN_CLOSET
        wrong: FAILED
        timeout: FAILED

FAILED:
    oh no you came out in front of the guy you're dead
    CHECKPOINT1

OPEN_CLOSET:
    hide for a while. not sure how to deal with time. for now will just use a small counter
    paths:
        WAIT_IN_CLOSET
        EXIT_CLOSET

WAIT_IN_CLOSET:
    you're hiding...
    self.incloset = true
    paths:
        OPEN_CLOSET

EXIT_CLOSET:
    if(self.inclosettime > 0):
        EXIT_ROOM
    else:
        EXIT_DEAD

EXIT_DEAD:
    take a guess what happens.
    CHECKPOINT1

EXIT_ROOM:
    nobody seems around anymore.. you see a floor plan: there's a communication room and a pod launcher
    paths:
        PICK_COMM
        PICK_POD

PICK_COMM:
    you're in the communication room. do you want to leave throught the interwebz?
    paths:
        FINISH_INTERWEBZ
        EXIT_ROOM

FINISH_INTERWEBZ:
    timedquest
    paths:
        solved: DONE_INTERWEBZ
        timeout: DEAD
        failed: DEAD

PICK_POD:
    you're in the pod room. do you want to leave with your current body?
    paths:
        FINISH_POD
        EXIT_ROOM

FINISH_POD:
    timedquest
    paths:
        solved: DONE_POD
        timeout: DEAD
        failed: DEAD

DONEINTERWEBZ:
    congratulations you escaped to the interweb
    FINISH

DONEPOD:
    you left toward the planet! hope you'll find a better life
    FINISH

esiste uno state della conversazione. è possibile convertirlo a path diversi se necessario, semplicemente moltiplicando il numero di nodi. lo state per cosa può essere usato? solo selezionare nodi diversi? o anche presentare rami diversi?

es selezionare nodi diversi:
NODOSCELTA:
    values:
        if self.var:
            NODORISULTATO1
        else:
            NODORISULTATO2

es presentare rami diversi:
NODOSCELTA:
    if self.var:
        paths:
            GIOVANNI
            GIORGIO
            ANTONIO
    else:
        paths:
            ANTONIO
            GIACOMO



basic planning:
    start room (you die if light) -> checkpoint -> room 2 (die if don't hide or hide too long) -> checkpoint -> communication room -> escape to the interwebz


state:
    self.pass  (a password was set)
    self.light (flashlight function enabled)

thoughts and requests on space story:
    20 nodes
    minimum 2 choices per node (cassata, regola di merda)
    at least 6 quizNodes
    death? restart? checkpoint! you upload you consciousness and you go through a couple questions to "verify you're ready" or whatever
    "Innessuncasouninputsbagliatofaprecipitare la storia verso una conclusione negativa. Questo non è un quiz, ma un modo per apprendere dei concetti.", rebuttal:
        1. per imparare, si rifanno le cose. i checkpoint sono un buon modo per imparare senza diventare noiosi
        2. 15-18 è più importante mantenere l'interesse. al museo non ne avranno mezza. ritenzione >>> apprendimento, perché l'apprendimento sarà successivo
        3. we need stakes. otherwise it will feel like a pointless excercise
    
    "Ognigioco deveavereunobiettivodidatticochiaroepreciso(adesempio,Napoleone Bonaparte, le equivalenze tra unità di misura, la struttura della cellula, l'analisi logica, ecc". this applies to us, as this story introduces thoughts about consciousness and identity, and the possible reality of alternative minds. we could include some more obvious references: nave di teseo, how complex behavior arises from simple rules, l'arbitrarietà del cosa è intelligente.







ordine del giorno: organizzare lo sviluppo (con percorsi individuali) del progetto di tec web. in particolare, ricordarsi di come eravamo d'accordo l'altra volta, hold the others accountable e rivedere l'organizzazione in luce dei nuovi sviluppi

Informazioni sul progetto
Ogni informazione sul progetto riporterà sempre i destinatari (tutti, 9CFU+6CFUold, solo 9CFU) e la data a partire dalla quale l'informazione diventerà vincolante (e.g. diventa un requisito obbligatorio per il progetto)

Q: Dato che ogni attività ha la possibilità di portare ad attività diverse in base alla risposta, dobbiamo permettere anche che una missione porti a missioni diverse in base alle attività svolte o possiamo considerare che le attività di una missione portino sempre allo stesso risultato?
A: Una storia è composta di missioni che sono composte di attività. Le missioni POSSONO essere parallele (ad esempio la mia squadra fa missione 1, 2 e 3, la tua fa 3, 2 4, ecc.) Questo significa che la sequenza delle missioni deve poter essere decisa in qualche maniera (ad esempio attraverso una proprietà nextMission statica oppure una funzione nextMission che sulla base dell'andamento della storia decide quale sarà la prossima missione (e quindi porta alla prima attività di quella missione).

​Q: E' possibile che per lo stesso gruppo ci siano missioni parallele, ad esempio la missione 2 è disponibile senza finire la missione 1 o sono per forza sequenziali? stessa domanda per le attività
​A: Mi sembra una complicazione inutile. Il gruppo esegue un'attività alla volta. e l'attività appartiene ad una missione. Se avessi due missioni attive contemporaneamente, vorrebbe dire che la stessa attività appartiene a due missioni, oppure che ho due attività da svolgere allo stesso tempo? Diventerebbe troppo complicato.

Q: Cosa intende (nella slide 34)con la frase "almeno un una (storia) per ogni tipo di gioco e per ogni fascia di età"
​Q: In tutto gli esempi devono essere 9 vero? 3 fasce di età diverse per ogni gruppo ( che sono 3 gruppi ). 
Q: È corretto creare un tipo di gioco (individuale, piccoli gruppi, classe) per ogni fascia d'età, oppure dobbiamo creare tutti i tipi di gioco per ciascuna fascia d'età? (9 in tutto).
A: Questa è una cosa che evidentemente non ho chiarito a sufficienza nelle slide e/o a voce. Ci sono tre tipi di gioco, e tre classi di età. Il numero d combinazioni dunque è nove. Di queste nove, voi dovete farne tre. Almeno tre, ovviamente. Scegliete voi cosa fare e vome metterle, ma una storia per ogni tipo di gioco e una storia per ogni tipo di età. Quindi ogni colonna e ogni riga della matrice tipo x età deve avere una casella occupata. Quale, lo scegliete voi.
tip/età  range 1 | range 2 | range 3
ind         [ ]      [x]      [ ]   
grup        [x]      [ ]      [ ]   
clas        [ ]      [ ]      [x]   

Q: che differenza c'è tra classe e gruppo, si possono unire i due gruppi in uno non individuale?
A: Quando l'abbiamo pensato, abbiamo ipotizzato la visita di ragazzi ad un museo. Quindi i ragazzi sono da soli, oppure in piccoli gruppi (tre/quattro ragazzi, anche di età diverse), oppure una classe (20-25 ragazzi della stessa età e un chiaro fine educativo). La vera differenza secondo me è che una classe non può muoversi tutta in blocco per realizzare le esperienze proposte dalla storia, per cui è necessario spezzare la storia in sequenze separate ed indipendenti che vengono attribuite a piccoli gruppi. Qui si possono far sorgere cose come competizione tra gruppi, gare di velocità o precisione, ecc. che rendono il gioco più interessante. 

Q: Ci sono vincoli riguardo le storie? Dobbiamo creare n storie diverse o possiamo riutilizzarne una per diversi tipi di gioco/fasce d'età? (Sarebbe in ogni caso nostra responsabilità il rendere la storia compatibile con gruppi di diverse dimensioni).
A: Le tre fasce di età si differenziano tra loro non solo per la vastità e sofisticazione dei contenuti delle storie, ma anche e soprattutto per il tipo di sfide che debbono essere loro proposte, sulla base dei modelli di ragionamento di Piaget e Bruner. Se riuscite a creare storia diverse all'interno della stessa trama, questo è ottimo. Sono un po' più scettico all'idea di riciclare attività e teesti.










