{"ast":null,"code":"var _jsxFileName = \"/home/hmny/Projects/M-and-M/client/src/Editor/components/GraphCanvas/index.js\";\nimport React, { useCallback, useRef, useState, useMemo, useEffect, useLayoutEffect } from 'react';\nimport Graph from '../../../common/Graph';\nimport { Options, getGraphFromStory, makeClusters, openClusters, cleanClusterEdges } from './GraphPreferences';\nimport { useEditor } from '../../context/EditorContext';\nimport './styles.css';\nconst clusterFactor = 0.9;\n\nconst GraphCanvas = () => {\n  //Reference of Graph component from react-vis-network\n  const networkRef = useRef(); //Basis for zoom comparation\n\n  const [lastClusterZoomLevel, setLastClusterZoomLevel] = useState(1);\n  const [clusteredMissions, setClusteredMissions] = useState([]); //How much zoom is needed, relative to lastClusterZoomLevel, for clustering\n\n  const {\n    story,\n\n    /*saveStory,*/\n    setWorkingActivity\n  } = useEditor();\n\n  const nodeExists = nodeId => {\n    var res = false;\n    networkRef.current.body.data.nodes.forEach(node => {\n      if (node.id === nodeId) res = true;\n    });\n    return res;\n  };\n  /* Memoization of events to avoid processing multiple calls because of rerenders */\n  // on doubleClick select node\n\n\n  const doubleClick = useCallback(event => {\n    const eventNode = event.nodes[0]; //If node is cluster open the cluster else setWorkingActivity to node\n\n    if (clusteredMissions.includes(eventNode) && networkRef.current.isCluster(eventNode)) {\n      networkRef.current.openCluster(eventNode, {\n        releaseFunction: (clusterPosition, containedNodesPositions) => {\n          return containedNodesPositions;\n        }\n      }); //Remove from clusteredMissions\n\n      clusteredMissions.splice(clusteredMissions.indexOf(eventNode), 1);\n    } else {\n      //Check if node is a story node, if it is continue else it means it's a cluster\n      if (nodeExists(eventNode)) {\n        const pos = story.nodes.findIndex(node => node.id === eventNode);\n        story.nodes[pos] = { ...story.nodes[pos]\n        };\n        setWorkingActivity(eventNode);\n      }\n    }\n  }, [setWorkingActivity, story.nodes, clusteredMissions]);\n  const deselectNode = useCallback(event => {\n    networkRef.current.disableEditMode();\n    setWorkingActivity(undefined);\n  }, [setWorkingActivity]);\n  useEffect(() => {\n    setLastClusterZoomLevel(networkRef.current.view.targetScale);\n  }, [lastClusterZoomLevel]);\n  /*\n    event: {\n      direction: '+'/'-',\n      scale: Number,\n      pointer: {x:pointer_x, y:pointer_y}\n    }\n  */\n\n  const zoom = useCallback(event => {\n    //Zooming out\n    if (event.direction === '-') {\n      if (clusteredMissions.length === 0) {\n        if (event.scale < lastClusterZoomLevel * clusterFactor) {\n          const missions = makeClusters(networkRef.current);\n          setLastClusterZoomLevel(event.scale);\n          setClusteredMissions(() => {\n            return missions;\n          });\n        }\n      } //Zooming in\n\n    } else {\n      if (clusteredMissions.length > 0) {\n        openClusters(networkRef.current);\n        setClusteredMissions([]);\n      }\n    }\n  }, [lastClusterZoomLevel, clusteredMissions]);\n  /*Clean graph library errors on automatic cluster edge creation */\n\n  useLayoutEffect(() => {\n    if (networkRef.current !== undefined) {\n      const handler = () => {\n        cleanClusterEdges(networkRef.current, clusteredMissions);\n      };\n\n      networkRef.current.on('afterDrawing', handler);\n      return () => {\n        networkRef.current.off('afterDrawing', handler);\n      };\n    }\n  }, [clusteredMissions]); // Enable drag-n-drop for nodes\n  // const onDropAddNode = useCallback(\n  //   event => {\n  //     event.preventDefault();\n  //     try {\n  //       const newNode = JSON.parse(event.dataTransfer.getData('text'));\n  //       const { nodes, ...others } = story;\n  //       saveStory({ nodes: [...nodes, newNode], ...others });\n  //     } catch (Error) {\n  //       return;\n  //     }\n  //   },\n  //   [saveStory, story]\n  // );\n\n  const events = useMemo(() => ({\n    doubleClick,\n    zoom,\n    deselectNode\n  }), [doubleClick, zoom, deselectNode]);\n  const getNetwork = useCallback(network => networkRef.current = network, []);\n  return /*#__PURE__*/React.createElement(Graph, {\n    data: getGraphFromStory(story),\n    options: Options,\n    events: events,\n    getNetwork: getNetwork,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 154,\n      columnNumber: 5\n    }\n  });\n};\n\nexport default GraphCanvas;","map":{"version":3,"sources":["/home/hmny/Projects/M-and-M/client/src/Editor/components/GraphCanvas/index.js"],"names":["React","useCallback","useRef","useState","useMemo","useEffect","useLayoutEffect","Graph","Options","getGraphFromStory","makeClusters","openClusters","cleanClusterEdges","useEditor","clusterFactor","GraphCanvas","networkRef","lastClusterZoomLevel","setLastClusterZoomLevel","clusteredMissions","setClusteredMissions","story","setWorkingActivity","nodeExists","nodeId","res","current","body","data","nodes","forEach","node","id","doubleClick","event","eventNode","includes","isCluster","openCluster","releaseFunction","clusterPosition","containedNodesPositions","splice","indexOf","pos","findIndex","deselectNode","disableEditMode","undefined","view","targetScale","zoom","direction","length","scale","missions","handler","on","off","events","getNetwork","network"],"mappings":"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","sourcesContent":["import React, {\n  useCallback,\n  useRef,\n  useState,\n  useMemo,\n  useEffect,\n  useLayoutEffect,\n} from 'react';\nimport Graph from '../../../common/Graph';\n\nimport {\n  Options,\n  getGraphFromStory,\n  makeClusters,\n  openClusters,\n  cleanClusterEdges,\n} from './GraphPreferences';\nimport { useEditor } from '../../context/EditorContext';\n\nimport './styles.css';\n\nconst clusterFactor = 0.9;\n\nconst GraphCanvas = () => {\n  //Reference of Graph component from react-vis-network\n  const networkRef = useRef();\n\n  //Basis for zoom comparation\n  const [lastClusterZoomLevel, setLastClusterZoomLevel] = useState(1);\n\n  const [clusteredMissions, setClusteredMissions] = useState([]);\n  //How much zoom is needed, relative to lastClusterZoomLevel, for clustering\n  const { story, /*saveStory,*/ setWorkingActivity } = useEditor();\n\n  const nodeExists = nodeId => {\n    var res = false;\n    networkRef.current.body.data.nodes.forEach(node => {\n      if (node.id === nodeId) res = true;\n    });\n\n    return res;\n  };\n\n  /* Memoization of events to avoid processing multiple calls because of rerenders */\n  // on doubleClick select node\n  const doubleClick = useCallback(\n    event => {\n      const eventNode = event.nodes[0];\n      //If node is cluster open the cluster else setWorkingActivity to node\n      if (\n        clusteredMissions.includes(eventNode) &&\n        networkRef.current.isCluster(eventNode)\n      ) {\n        networkRef.current.openCluster(eventNode, {\n          releaseFunction: (clusterPosition, containedNodesPositions) => {\n            return containedNodesPositions;\n          },\n        });\n        //Remove from clusteredMissions\n        clusteredMissions.splice(clusteredMissions.indexOf(eventNode), 1);\n      } else {\n        //Check if node is a story node, if it is continue else it means it's a cluster\n        if (nodeExists(eventNode)) {\n          const pos = story.nodes.findIndex(node => node.id === eventNode);\n          story.nodes[pos] = { ...story.nodes[pos] };\n          setWorkingActivity(eventNode);\n        }\n      }\n    },\n    [setWorkingActivity, story.nodes, clusteredMissions]\n  );\n\n  const deselectNode = useCallback(\n    event => {\n      networkRef.current.disableEditMode();\n      setWorkingActivity(undefined);\n    },\n    [setWorkingActivity]\n  );\n\n  useEffect(() => {\n    setLastClusterZoomLevel(networkRef.current.view.targetScale);\n  }, [lastClusterZoomLevel]);\n\n  /*\n    event: {\n      direction: '+'/'-',\n      scale: Number,\n      pointer: {x:pointer_x, y:pointer_y}\n    }\n  */\n  const zoom = useCallback(\n    event => {\n      //Zooming out\n\n      if (event.direction === '-') {\n        if (clusteredMissions.length === 0) {\n          if (event.scale < lastClusterZoomLevel * clusterFactor) {\n            const missions = makeClusters(networkRef.current);\n            setLastClusterZoomLevel(event.scale);\n            setClusteredMissions(() => {\n              return missions;\n            });\n          }\n        }\n        //Zooming in\n      } else {\n        if (clusteredMissions.length > 0) {\n          openClusters(networkRef.current);\n          setClusteredMissions([]);\n        }\n      }\n    },\n    [lastClusterZoomLevel, clusteredMissions]\n  );\n  /*Clean graph library errors on automatic cluster edge creation */\n  useLayoutEffect(() => {\n    if (networkRef.current !== undefined) {\n      const handler = () => {\n        cleanClusterEdges(networkRef.current, clusteredMissions);\n      };\n      networkRef.current.on('afterDrawing', handler);\n      return () => {\n        networkRef.current.off('afterDrawing', handler);\n      };\n    }\n  }, [clusteredMissions]);\n\n  // Enable drag-n-drop for nodes\n  // const onDropAddNode = useCallback(\n  //   event => {\n  //     event.preventDefault();\n\n  //     try {\n  //       const newNode = JSON.parse(event.dataTransfer.getData('text'));\n  //       const { nodes, ...others } = story;\n  //       saveStory({ nodes: [...nodes, newNode], ...others });\n  //     } catch (Error) {\n  //       return;\n  //     }\n  //   },\n  //   [saveStory, story]\n  // );\n\n  const events = useMemo(() => ({ doubleClick, zoom, deselectNode }), [\n    doubleClick,\n    zoom,\n    deselectNode,\n  ]);\n\n  const getNetwork = useCallback(network => (networkRef.current = network), []);\n\n  return (\n    <Graph\n      data={getGraphFromStory(story)}\n      options={Options}\n      events={events}\n      getNetwork={getNetwork}\n    />\n  );\n};\n\nexport default GraphCanvas;\n"]},"metadata":{},"sourceType":"module"}