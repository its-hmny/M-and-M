{"ast":null,"code":"export const Options = {\n  autoResize: true,\n\n  /* Capolavoro d'ingegneria del software, dovrebbe\n      essere mostrato ad un museo d'arte */\n  width: '100vw',\n  height: '100vh',\n  configure: {\n    enabled: false,\n\n    /* nodes, edges, layout, interaction, manipulation, physics, selection, renderer */\n    showButton: false\n  },\n  nodes: {\n    borderWidth: 2,\n    borderWidthSelected: 2.5,\n    font: {\n      size: 20,\n      color: 'white',\n      background: 'none',\n      align: 'center'\n    },\n    shape: 'dot',\n    size: 20,\n    color: 'orange'\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: true\n      }\n    },\n    color: {\n      color: 'white',\n      highlight: 'white'\n    }\n  },\n  layout: {\n    improvedLayout: true,\n    hierarchical: {\n      enabled: false,\n      direction: 'LR',\n      levelSeparation: 150,\n      nodeSpacing: 100,\n      edgeMinimization: true,\n      parentCentralization: false\n    }\n  },\n  interaction: {\n    dragNodes: true,\n    dragView: true,\n    hover: false,\n    keyboard: {\n      enabled: true,\n      bindToWindow: false\n    },\n    selectable: true,\n    multiselect: true,\n    navigationButtons: false,\n    zoomView: true\n  },\n  manipulation: {\n    enabled: false,\n    initiallyActive: false,\n    addEdge: (edgeData, callback) => {\n      if (edgeData.from !== edgeData.to) {\n        var r = window.confirm('Do you want to connect the node to itself?');\n        if (r === true) callback(edgeData);\n      }\n    }\n  },\n  physics: {\n    enabled: false,\n    solver: 'repulsion',\n    repulsion: {\n      nodeDistance: 400 // Put more distance between the nodes.\n\n    }\n  }\n};\nexport const getGraphFromStory = story => {\n  if (!story) return {\n    nodes: [],\n    edges: []\n  };\n  const graph = {\n    nodes: [],\n    edges: []\n  };\n  story.nodes.forEach(node => {\n    graph.nodes = [...graph.nodes, { ...node,\n      label: node.name,\n      mission: node.mission\n    }];\n    setEdgesFromChildren(node.components, node.id, graph);\n  });\n  return graph;\n};\n\nconst setEdgesFromChildren = (root, rootId, graph) => {\n  root.forEach(child => {\n    if (child.story && child.story.nextNode) {\n      if (typeof child.story.nextNode === 'string') {\n        graph.edges = [...graph.edges, {\n          from: rootId,\n          to: child.story.nextNode\n        }];\n      } else {\n        graph.edges = [...graph.edges, {\n          from: rootId,\n          to: child.story.nextNode['[CORRECT]']\n        }, {\n          from: rootId,\n          to: child.story.nextNode['[WRONG]']\n        }];\n      }\n    } else if (child.children instanceof Array) setEdgesFromChildren(child.children, rootId, graph);\n  });\n};\n\nexport const highlightPath = (graph, path) => {\n  const touchedNodes = path.map(node => node.activityNodeId); // Al the reached node became triangles\n\n  graph.nodes.forEach(node => {\n    if (touchedNodes.find(id => id === node.id)) node.shape = 'hexagon';else node.shape = 'dot';\n  }); // Edge highlighting part\n\n  graph.edges.forEach(edge => edge.color = '#ffffff'); // Resets to default\n\n  for (let prev = 0, next = 1; next < touchedNodes.length; prev++, next++) {\n    const edgeToHighlight = graph.edges.find(edge => edge.from === touchedNodes[prev] && edge.to === touchedNodes[next]);\n    if (edgeToHighlight) edgeToHighlight.color = 'black';\n  }\n\n  return graph;\n};\nexport const makeClusters = network => {\n  const missions = getMissions(network);\n\n  if (missions.length !== 0) {\n    missions.forEach(mission => {\n      const options = {\n        joinCondition: currentNodeOptions => {\n          if (currentNodeOptions.mission === undefined) {\n            return false;\n          } else return currentNodeOptions.mission === mission;\n        },\n        clusterNodeProperties: {\n          id: mission,\n          font: {\n            color: 'black',\n            size: '40'\n          },\n          borderWidth: 3,\n          shape: 'database',\n          label: mission,\n          allowSingleNodeCluster: true\n        },\n        clusterEdgeProperties: {}\n      };\n      network.clustering.cluster(options);\n    });\n  }\n\n  return missions;\n};\nexport const openClusters = network => {\n  const missions = getMissions(network);\n  missions.forEach(mission => {\n    if (network.isCluster(mission)) {\n      network.openCluster(mission, {\n        releaseFunction: (clusterPosition, containedNodesPositions) => {\n          return containedNodesPositions;\n        }\n      });\n    }\n  });\n\n  if (network.isCluster(undefined)) {\n    network.openCluster(undefined, {\n      releaseFunction: (clusterPosition, containedNodesPositions) => {\n        return containedNodesPositions;\n      }\n    });\n  }\n};\n\nconst getMissions = network => {\n  const missions = [];\n  /*Populating mission database \n    (there isn't a central db because it wasn't necessary)\n  */\n  //Getting node data we set from network.body.nodes[i].options\n\n  if (network !== undefined) {\n    network.body.data.nodes.forEach(node => {\n      if (!missions.includes(node.mission)) {\n        missions.push(node.mission);\n      }\n    });\n  }\n\n  return missions;\n};\n\nexport const cleanClusterEdges = (network, missions) => {\n  if (network !== undefined) {\n    Object.entries(network.body.edges).forEach(([key, edge]) => {\n      if (key.includes('clusterEdge') && (!missions.includes(edge.toId) || !missions.includes(edge.fromId))) {\n        edge.options.hidden = true;\n      }\n    });\n  }\n};","map":{"version":3,"sources":["/home/hmny/Projects/M-and-M/client/src/Editor/components/GraphCanvas/GraphPreferences.js"],"names":["Options","autoResize","width","height","configure","enabled","showButton","nodes","borderWidth","borderWidthSelected","font","size","color","background","align","shape","edges","arrows","to","highlight","layout","improvedLayout","hierarchical","direction","levelSeparation","nodeSpacing","edgeMinimization","parentCentralization","interaction","dragNodes","dragView","hover","keyboard","bindToWindow","selectable","multiselect","navigationButtons","zoomView","manipulation","initiallyActive","addEdge","edgeData","callback","from","r","window","confirm","physics","solver","repulsion","nodeDistance","getGraphFromStory","story","graph","forEach","node","label","name","mission","setEdgesFromChildren","components","id","root","rootId","child","nextNode","children","Array","highlightPath","path","touchedNodes","map","activityNodeId","find","edge","prev","next","length","edgeToHighlight","makeClusters","network","missions","getMissions","options","joinCondition","currentNodeOptions","undefined","clusterNodeProperties","allowSingleNodeCluster","clusterEdgeProperties","clustering","cluster","openClusters","isCluster","openCluster","releaseFunction","clusterPosition","containedNodesPositions","body","data","includes","push","cleanClusterEdges","Object","entries","key","toId","fromId","hidden"],"mappings":"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","sourcesContent":["export const Options = {\n  autoResize: true,\n  /* Capolavoro d'ingegneria del software, dovrebbe\n      essere mostrato ad un museo d'arte */\n  width: '100vw',\n  height: '100vh',\n\n  configure: {\n    enabled: false,\n\n    /* nodes, edges, layout, interaction, manipulation, physics, selection, renderer */\n    showButton: false,\n  },\n\n  nodes: {\n    borderWidth: 2,\n    borderWidthSelected: 2.5,\n\n    font: {\n      size: 20,\n      color: 'white',\n      background: 'none',\n      align: 'center',\n    },\n\n    shape: 'dot',\n    size: 20,\n    color: 'orange',\n  },\n\n  edges: {\n    arrows: { to: { enabled: true } },\n    color: { color: 'white', highlight: 'white' },\n  },\n\n  layout: {\n    improvedLayout: true,\n    hierarchical: {\n      enabled: false,\n      direction: 'LR',\n      levelSeparation: 150,\n      nodeSpacing: 100,\n      edgeMinimization: true,\n      parentCentralization: false,\n    },\n  },\n\n  interaction: {\n    dragNodes: true,\n    dragView: true,\n    hover: false,\n    keyboard: { enabled: true, bindToWindow: false },\n    selectable: true,\n    multiselect: true,\n    navigationButtons: false,\n    zoomView: true,\n  },\n\n  manipulation: {\n    enabled: false,\n    initiallyActive: false,\n    addEdge: (edgeData, callback) => {\n      if (edgeData.from !== edgeData.to) {\n        var r = window.confirm('Do you want to connect the node to itself?');\n        if (r === true) callback(edgeData);\n      }\n    },\n  },\n\n  physics: {\n    enabled: false,\n    solver: 'repulsion',\n    repulsion: {\n      nodeDistance: 400, // Put more distance between the nodes.\n    },\n  },\n};\n\nexport const getGraphFromStory = story => {\n  if (!story) return { nodes: [], edges: [] };\n\n  const graph = { nodes: [], edges: [] };\n\n  story.nodes.forEach(node => {\n    graph.nodes = [...graph.nodes, { ...node, label: node.name, mission: node.mission }];\n    setEdgesFromChildren(node.components, node.id, graph);\n  });\n\n  return graph;\n};\n\nconst setEdgesFromChildren = (root, rootId, graph) => {\n  root.forEach(child => {\n    if (child.story && child.story.nextNode) {\n      if (typeof child.story.nextNode === 'string') {\n        graph.edges = [...graph.edges, { from: rootId, to: child.story.nextNode }];\n      } else {\n        graph.edges = [\n          ...graph.edges,\n          { from: rootId, to: child.story.nextNode['[CORRECT]'] },\n          { from: rootId, to: child.story.nextNode['[WRONG]'] },\n        ];\n      }\n    } else if (child.children instanceof Array)\n      setEdgesFromChildren(child.children, rootId, graph);\n  });\n};\n\nexport const highlightPath = (graph, path) => {\n  const touchedNodes = path.map(node => node.activityNodeId);\n  // Al the reached node became triangles\n  graph.nodes.forEach(node => {\n    if (touchedNodes.find(id => id === node.id)) node.shape = 'hexagon';\n    else node.shape = 'dot';\n  });\n  // Edge highlighting part\n  graph.edges.forEach(edge => (edge.color = '#ffffff')); // Resets to default\n  for (let prev = 0, next = 1; next < touchedNodes.length; prev++, next++) {\n    const edgeToHighlight = graph.edges.find(\n      edge => edge.from === touchedNodes[prev] && edge.to === touchedNodes[next]\n    );\n    if (edgeToHighlight) edgeToHighlight.color = 'black';\n  }\n  return graph;\n};\n\nexport const makeClusters = network => {\n  const missions = getMissions(network);\n\n  if (missions.length !== 0) {\n    missions.forEach(mission => {\n      const options = {\n        joinCondition: currentNodeOptions => {\n          if (currentNodeOptions.mission === undefined) {\n            return false;\n          } else return currentNodeOptions.mission === mission;\n        },\n        clusterNodeProperties: {\n          id: mission,\n          font: {\n            color: 'black',\n            size: '40',\n          },\n          borderWidth: 3,\n          shape: 'database',\n          label: mission,\n          allowSingleNodeCluster: true,\n        },\n        clusterEdgeProperties: {},\n      };\n      network.clustering.cluster(options);\n    });\n  }\n\n  return missions;\n};\n\nexport const openClusters = network => {\n  const missions = getMissions(network);\n\n  missions.forEach(mission => {\n    if (network.isCluster(mission)) {\n      network.openCluster(mission, {\n        releaseFunction: (clusterPosition, containedNodesPositions) => {\n          return containedNodesPositions;\n        },\n      });\n    }\n  });\n\n  if (network.isCluster(undefined)) {\n    network.openCluster(undefined, {\n      releaseFunction: (clusterPosition, containedNodesPositions) => {\n        return containedNodesPositions;\n      },\n    });\n  }\n};\n\nconst getMissions = network => {\n  const missions = [];\n  /*Populating mission database \n    (there isn't a central db because it wasn't necessary)\n  */\n  //Getting node data we set from network.body.nodes[i].options\n  if (network !== undefined) {\n    network.body.data.nodes.forEach(node => {\n      if (!missions.includes(node.mission)) {\n        missions.push(node.mission);\n      }\n    });\n  }\n\n  return missions;\n};\n\nexport const cleanClusterEdges = (network, missions) => {\n  if (network !== undefined) {\n    Object.entries(network.body.edges).forEach(([key, edge]) => {\n      if (\n        key.includes('clusterEdge') &&\n        (!missions.includes(edge.toId) || !missions.includes(edge.fromId))\n      ) {\n        edge.options.hidden = true;\n      }\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"module"}