{"ast":null,"code":"var _jsxFileName = \"/home/hmny/Projects/M-and-M/client/src/Evaluator/context/EvaluatorContext.js\";\nimport React, { useContext, useState, useEffect, useMemo, useCallback } from 'react';\nimport { useSnackbar } from 'notistack';\nimport axios, { useQuery } from '../../common/shared';\nimport { SERVER_URL } from '../../common/constants';\nimport io from 'socket.io-client';\nimport { useHistory } from 'react-router-dom';\nimport * as ROUTES from '../../routes';\nconst EvaluatorContext = React.createContext();\nexport const EvaluatorProvider = ({\n  children\n}) => {\n  const {\n    storyId\n  } = useQuery();\n  const history = useHistory();\n  const {\n    enqueueSnackbar\n  } = useSnackbar();\n  const [focusedPlayer, setFocusedPlayer] = useState(undefined);\n  const [playersLog, setPlayersLog] = useState([]);\n  const [story, setStory] = useState(undefined);\n  const socket = useMemo(() => io(SERVER_URL, {\n    query: {\n      type: 'evaluator',\n      storyId\n    }\n  }), [storyId]);\n  useEffect(() => {\n    // onMount load the story and the player log on the server\n    const fetchAll = async () => {\n      try {\n        const loadedStory = (await axios.get(`/stories/${storyId}`)).data.payload;\n        setStory(loadedStory);\n      } catch (err) {\n        history.push(ROUTES.NOTFOUND);\n      }\n    };\n\n    fetchAll();\n  }, [history, storyId]);\n  const updatePlayerLog = useCallback((playerId, patch) => socket.emit('update:eval', {\n    story: storyId,\n    playerId,\n    patch\n  }), [socket, storyId]);\n  const pushNotification = useCallback(msg => enqueueSnackbar(msg, {\n    variant: 'default'\n  }), [enqueueSnackbar]);\n  useEffect(() => {\n    if (!socket) return;\n\n    const mergePlayerLog = (playerLog, patch) => {\n      playerLog = { ...playerLog,\n        ...patch\n      }; // Merge the changes\n\n      setPlayersLog(playersLog.map(log => {\n        if (log.id === playerLog.id) return playerLog;else return log;\n      }));\n    }; // Saves in the context the player position in the story\n\n\n    socket.on('update:position', data => {\n      const {\n        story,\n        senderId,\n        payload\n      } = data;\n\n      if (story === storyId) {\n        let playerLog = playersLog.find(player => player.id === senderId);\n        if (playerLog) mergePlayerLog(playerLog, payload);\n      }\n    }); // Saves in the context the player responses and changes to the story's components\n\n    socket.on('update:stats', data => {\n      const {\n        story,\n        senderId,\n        payload\n      } = data;\n\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === senderId);\n\n        if (playerLog) {\n          // There's a new ending evaluation for that player\n          const {\n            name,\n            id\n          } = playerLog;\n          if (playerLog.pendingEvaluation.length < payload.pendingEvaluation.length) pushNotification(`New evaluation requested by ${name || id}`);\n          mergePlayerLog(playerLog, payload);\n        }\n      }\n    });\n    socket.on('chat-msg-recv', data => {\n      const {\n        story,\n        senderId,\n        receiverId,\n        msg\n      } = data;\n\n      if (story === storyId) {\n        const playerId = senderId === `evaluator${storyId}` ? receiverId : senderId;\n        const playerLog = playersLog.find(player => player.id === playerId);\n\n        if (playerLog) {\n          const toSave = {\n            sender: senderId,\n            content: msg\n          };\n          playerLog.chatLog = [...playerLog.chatLog, toSave]; // Maybe updatePlayerLog\n\n          if (senderId !== `evaluator${storyId}`) {\n            pushNotification(`New message from ${playerLog.name || playerLog.id}`);\n            playerLog.unreadMessages++;\n          }\n\n          mergePlayerLog(playerLog, playerLog);\n        }\n      }\n    });\n    socket.on('update:eval', data => {\n      const {\n        story,\n        playerId,\n        newLog\n      } = data;\n\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === playerId);\n        if (playerLog) mergePlayerLog(playerLog, newLog);\n      }\n    });\n    socket.on('add:player', data => {\n      const {\n        story,\n        payload\n      } = data;\n      if (story === storyId) setPlayersLog([...playersLog, payload]);\n    });\n    socket.on('get:log', data => {\n      const {\n        story,\n        payload\n      } = data;\n\n      if (story === storyId && payload) {\n        setPlayersLog(payload);\n        setFocusedPlayer((payload[0] || {}).id);\n      }\n    });\n    socket.on('rm:player', data => {\n      const {\n        story,\n        playerId\n      } = data;\n\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === playerId);\n\n        if (playerLog) {\n          playerLog.isDisconnected = true;\n          mergePlayerLog(playerLog, playerLog);\n        }\n      }\n    }); // This has to be checked\n\n    return () => socket.removeAllListeners();\n  }, [socket, playersLog, storyId, pushNotification]);\n  const toProvide = {\n    story,\n    storyId,\n    playersLog,\n    pushNotification,\n    selectedPlayer: playersLog.find(player => player.id === focusedPlayer),\n    setFocusedPlayer,\n    updatePlayerLog,\n    socket\n  };\n  return /*#__PURE__*/React.createElement(EvaluatorContext.Provider, {\n    value: toProvide,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 152,\n      columnNumber: 5\n    }\n  }, children);\n};\nexport const useEvaluator = () => {\n  const value = useContext(EvaluatorContext);\n\n  if (value == null) {\n    throw new Error('useEvaluator must be used inside an EvaluatorProvider');\n  }\n\n  return value;\n};","map":{"version":3,"sources":["/home/hmny/Projects/M-and-M/client/src/Evaluator/context/EvaluatorContext.js"],"names":["React","useContext","useState","useEffect","useMemo","useCallback","useSnackbar","axios","useQuery","SERVER_URL","io","useHistory","ROUTES","EvaluatorContext","createContext","EvaluatorProvider","children","storyId","history","enqueueSnackbar","focusedPlayer","setFocusedPlayer","undefined","playersLog","setPlayersLog","story","setStory","socket","query","type","fetchAll","loadedStory","get","data","payload","err","push","NOTFOUND","updatePlayerLog","playerId","patch","emit","pushNotification","msg","variant","mergePlayerLog","playerLog","map","log","id","on","senderId","find","player","name","pendingEvaluation","length","receiverId","toSave","sender","content","chatLog","unreadMessages","newLog","isDisconnected","removeAllListeners","toProvide","selectedPlayer","useEvaluator","value","Error"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect, useMemo, useCallback } from 'react';\nimport { useSnackbar } from 'notistack';\nimport axios, { useQuery } from '../../common/shared';\nimport { SERVER_URL } from '../../common/constants';\n\nimport io from 'socket.io-client';\nimport { useHistory } from 'react-router-dom';\nimport * as ROUTES from '../../routes';\n\nconst EvaluatorContext = React.createContext();\n\nexport const EvaluatorProvider = ({ children }) => {\n  const { storyId } = useQuery();\n  const history = useHistory();\n  const { enqueueSnackbar } = useSnackbar();\n  const [focusedPlayer, setFocusedPlayer] = useState(undefined);\n  const [playersLog, setPlayersLog] = useState([]);\n  const [story, setStory] = useState(undefined);\n\n  const socket = useMemo(\n    () => io(SERVER_URL, { query: { type: 'evaluator', storyId } }),\n    [storyId]\n  );\n\n  useEffect(() => {\n    // onMount load the story and the player log on the server\n    const fetchAll = async () => {\n      try {\n        const loadedStory = (await axios.get(`/stories/${storyId}`)).data.payload;\n        setStory(loadedStory);\n      } catch (err) {\n        history.push(ROUTES.NOTFOUND);\n      }\n    };\n\n    fetchAll();\n  }, [history, storyId]);\n\n  const updatePlayerLog = useCallback(\n    (playerId, patch) => socket.emit('update:eval', { story: storyId, playerId, patch }),\n    [socket, storyId]\n  );\n\n  const pushNotification = useCallback(\n    msg => enqueueSnackbar(msg, { variant: 'default' }),\n    [enqueueSnackbar]\n  );\n\n  useEffect(() => {\n    if (!socket) return;\n\n    const mergePlayerLog = (playerLog, patch) => {\n      playerLog = { ...playerLog, ...patch }; // Merge the changes\n      setPlayersLog(\n        playersLog.map(log => {\n          if (log.id === playerLog.id) return playerLog;\n          else return log;\n        })\n      );\n    };\n\n    // Saves in the context the player position in the story\n    socket.on('update:position', data => {\n      const { story, senderId, payload } = data;\n      if (story === storyId) {\n        let playerLog = playersLog.find(player => player.id === senderId);\n        if (playerLog) mergePlayerLog(playerLog, payload);\n      }\n    });\n\n    // Saves in the context the player responses and changes to the story's components\n    socket.on('update:stats', data => {\n      const { story, senderId, payload } = data;\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === senderId);\n        if (playerLog) {\n          // There's a new ending evaluation for that player\n          const { name, id } = playerLog;\n          if (playerLog.pendingEvaluation.length < payload.pendingEvaluation.length)\n            pushNotification(`New evaluation requested by ${name || id}`);\n          mergePlayerLog(playerLog, payload);\n        }\n      }\n    });\n\n    socket.on('chat-msg-recv', data => {\n      const { story, senderId, receiverId, msg } = data;\n      if (story === storyId) {\n        const playerId = senderId === `evaluator${storyId}` ? receiverId : senderId;\n        const playerLog = playersLog.find(player => player.id === playerId);\n        if (playerLog) {\n          const toSave = { sender: senderId, content: msg };\n          playerLog.chatLog = [...playerLog.chatLog, toSave];\n          // Maybe updatePlayerLog\n          if (senderId !== `evaluator${storyId}`) {\n            pushNotification(`New message from ${playerLog.name || playerLog.id}`);\n            playerLog.unreadMessages++;\n          }\n          mergePlayerLog(playerLog, playerLog);\n        }\n      }\n    });\n\n    socket.on('update:eval', data => {\n      const { story, playerId, newLog } = data;\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === playerId);\n        if (playerLog) mergePlayerLog(playerLog, newLog);\n      }\n    });\n\n    socket.on('add:player', data => {\n      const { story, payload } = data;\n      if (story === storyId) setPlayersLog([...playersLog, payload]);\n    });\n\n    socket.on('get:log', data => {\n      const { story, payload } = data;\n      if (story === storyId && payload) {\n        setPlayersLog(payload);\n        setFocusedPlayer((payload[0] || {}).id);\n      }\n    });\n\n    socket.on('rm:player', data => {\n      const { story, playerId } = data;\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === playerId);\n        if (playerLog) {\n          playerLog.isDisconnected = true;\n          mergePlayerLog(playerLog, playerLog);\n        }\n      }\n    });\n\n    // This has to be checked\n    return () => socket.removeAllListeners();\n  }, [socket, playersLog, storyId, pushNotification]);\n\n  const toProvide = {\n    story,\n    storyId,\n    playersLog,\n    pushNotification,\n    selectedPlayer: playersLog.find(player => player.id === focusedPlayer),\n    setFocusedPlayer,\n    updatePlayerLog,\n    socket,\n  };\n\n  return (\n    <EvaluatorContext.Provider value={toProvide}>{children}</EvaluatorContext.Provider>\n  );\n};\n\nexport const useEvaluator = () => {\n  const value = useContext(EvaluatorContext);\n  if (value == null) {\n    throw new Error('useEvaluator must be used inside an EvaluatorProvider');\n  }\n\n  return value;\n};\n"]},"metadata":{},"sourceType":"module"}