{"ast":null,"code":"var _jsxFileName = \"/home/hmny/Projects/M-and-M/client/src/Evaluator/context/EvaluatorContext.js\";\nimport React, { useContext, useState, useEffect, useMemo, useCallback } from 'react';\nimport { useSnackbar } from 'notistack';\nimport { Typography } from '@material-ui/core';\nimport axios, { useQuery } from '../../common/shared';\nimport { SERVER_URL } from '../../common/constants';\nimport io from 'socket.io-client';\nimport { useHistory } from 'react-router-dom';\nimport * as ROUTES from '../../routes';\nconst EvaluatorContext = React.createContext();\nexport const EvaluatorProvider = ({\n  children\n}) => {\n  const {\n    storyId\n  } = useQuery();\n  const history = useHistory();\n  const {\n    enqueueSnackbar\n  } = useSnackbar();\n  const [focusedPlayer, setFocusedPlayer] = useState(undefined);\n  const [playersLog, setPlayersLog] = useState([]);\n  const [story, setStory] = useState(undefined);\n  const [loadedStory, setLoadedStory] = useState(false);\n  const socket = useMemo(() => io(SERVER_URL, {\n    query: {\n      type: 'evaluator',\n      storyId\n    }\n  }), [storyId]);\n  useEffect(() => {\n    // onMount load the story and the player log on the server\n    const fetchAll = async () => {\n      try {\n        const loadedStory = (await axios.get(`/stories/${storyId}`)).data.payload;\n        setStory(loadedStory);\n        setLoadedStory(true);\n      } catch (err) {\n        history.push(ROUTES.NOTFOUND);\n      }\n    };\n\n    fetchAll();\n  }, [history, storyId]);\n  const updatePlayerLog = useCallback((playerId, patch) => socket.emit('update:eval', {\n    story: storyId,\n    playerId,\n    patch\n  }), [socket, storyId]);\n  const pushNotification = useCallback(msg => enqueueSnackbar(msg, {\n    variant: 'default'\n  }), [enqueueSnackbar]);\n  useEffect(() => {\n    if (!socket) return;\n\n    const mergePlayerLog = (playerLog, patch) => {\n      playerLog = { ...playerLog,\n        ...patch\n      }; // Merge the changes\n\n      setPlayersLog(playersLog.map(log => {\n        if (log.id === playerLog.id) return playerLog;else return log;\n      }));\n    }; // Saves in the context the player position in the story\n\n\n    socket.on('update:position', data => {\n      const {\n        story,\n        senderId,\n        payload\n      } = data;\n\n      if (story === storyId) {\n        let playerLog = playersLog.find(player => player.id === senderId);\n        if (playerLog) mergePlayerLog(playerLog, payload);\n      }\n    }); // Saves in the context the player responses and changes to the story's components\n\n    socket.on('update:stats', data => {\n      const {\n        story,\n        senderId,\n        payload\n      } = data;\n\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === senderId);\n\n        if (playerLog) {\n          // There's a new ending evaluation for that player\n          const {\n            name,\n            id\n          } = playerLog;\n          if (playerLog.pendingEvaluation.length < payload.pendingEvaluation.length) pushNotification(`New evaluation requested by ${name || id}`);\n          mergePlayerLog(playerLog, payload);\n        }\n      }\n    });\n    socket.on('chat-msg-recv', data => {\n      const {\n        story,\n        senderId,\n        receiverId,\n        msg\n      } = data;\n\n      if (story === storyId) {\n        const playerId = senderId === `evaluator${storyId}` ? receiverId : senderId;\n        const playerLog = playersLog.find(player => player.id === playerId);\n\n        if (playerLog) {\n          const toSave = {\n            sender: senderId,\n            content: msg\n          };\n          playerLog.chatLog = [...playerLog.chatLog, toSave]; // Maybe updatePlayerLog\n\n          if (senderId !== `evaluator${storyId}`) {\n            pushNotification(`New message from ${playerLog.name || playerLog.id}`);\n            playerLog.unreadMessages++;\n          }\n\n          mergePlayerLog(playerLog, playerLog);\n        }\n      }\n    });\n    socket.on('update:eval', data => {\n      const {\n        story,\n        playerId,\n        newLog\n      } = data;\n\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === playerId);\n        if (playerLog) mergePlayerLog(playerLog, newLog);\n      }\n    });\n    socket.on('add:player', data => {\n      const {\n        story,\n        payload\n      } = data;\n      if (story === storyId) setPlayersLog([...playersLog, payload]);\n    });\n    socket.on('get:log', data => {\n      const {\n        story,\n        payload\n      } = data;\n\n      if (story === storyId && payload) {\n        setPlayersLog(payload);\n        setFocusedPlayer((payload[0] || {}).id);\n      }\n    });\n    socket.on('rm:player', data => {\n      const {\n        story,\n        playerId\n      } = data;\n\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === playerId);\n\n        if (playerLog) {\n          playerLog.isDisconnected = true;\n          mergePlayerLog(playerLog, playerLog);\n        }\n      }\n    }); // This has to be checked\n\n    return () => socket.removeAllListeners();\n  }, [socket, playersLog, storyId, pushNotification]);\n\n  if (!loadedStory) {\n    return /*#__PURE__*/React.createElement(Typography, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 144,\n        columnNumber: 12\n      }\n    }, \"Loading...\");\n  }\n\n  const toProvide = {\n    story,\n    storyId,\n    playersLog,\n    pushNotification,\n    selectedPlayer: playersLog.find(player => player.id === focusedPlayer),\n    setFocusedPlayer,\n    updatePlayerLog,\n    socket\n  };\n  return /*#__PURE__*/React.createElement(EvaluatorContext.Provider, {\n    value: toProvide,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 5\n    }\n  }, children);\n};\nexport const useEvaluator = () => {\n  const value = useContext(EvaluatorContext);\n\n  if (value == null) {\n    throw new Error('useEvaluator must be used inside an EvaluatorProvider');\n  }\n\n  return value;\n};","map":{"version":3,"sources":["/home/hmny/Projects/M-and-M/client/src/Evaluator/context/EvaluatorContext.js"],"names":["React","useContext","useState","useEffect","useMemo","useCallback","useSnackbar","Typography","axios","useQuery","SERVER_URL","io","useHistory","ROUTES","EvaluatorContext","createContext","EvaluatorProvider","children","storyId","history","enqueueSnackbar","focusedPlayer","setFocusedPlayer","undefined","playersLog","setPlayersLog","story","setStory","loadedStory","setLoadedStory","socket","query","type","fetchAll","get","data","payload","err","push","NOTFOUND","updatePlayerLog","playerId","patch","emit","pushNotification","msg","variant","mergePlayerLog","playerLog","map","log","id","on","senderId","find","player","name","pendingEvaluation","length","receiverId","toSave","sender","content","chatLog","unreadMessages","newLog","isDisconnected","removeAllListeners","toProvide","selectedPlayer","useEvaluator","value","Error"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect, useMemo, useCallback } from 'react';\nimport { useSnackbar } from 'notistack';\nimport { Typography } from '@material-ui/core';\nimport axios, { useQuery } from '../../common/shared';\nimport { SERVER_URL } from '../../common/constants';\n\nimport io from 'socket.io-client';\nimport { useHistory } from 'react-router-dom';\nimport * as ROUTES from '../../routes';\n\nconst EvaluatorContext = React.createContext();\n\nexport const EvaluatorProvider = ({ children }) => {\n  const { storyId } = useQuery();\n  const history = useHistory();\n  const { enqueueSnackbar } = useSnackbar();\n  const [focusedPlayer, setFocusedPlayer] = useState(undefined);\n  const [playersLog, setPlayersLog] = useState([]);\n  const [story, setStory] = useState(undefined);\n  const [loadedStory, setLoadedStory] = useState(false);\n\n  const socket = useMemo(\n    () => io(SERVER_URL, { query: { type: 'evaluator', storyId } }),\n    [storyId]\n  );\n\n  useEffect(() => {\n    // onMount load the story and the player log on the server\n    const fetchAll = async () => {\n      try {\n        const loadedStory = (await axios.get(`/stories/${storyId}`)).data.payload;\n        setStory(loadedStory);\n        setLoadedStory(true);\n      } catch (err) {\n        history.push(ROUTES.NOTFOUND);\n      }\n    };\n\n    fetchAll();\n  }, [history, storyId]);\n\n  const updatePlayerLog = useCallback(\n    (playerId, patch) => socket.emit('update:eval', { story: storyId, playerId, patch }),\n    [socket, storyId]\n  );\n\n  const pushNotification = useCallback(\n    msg => enqueueSnackbar(msg, { variant: 'default' }),\n    [enqueueSnackbar]\n  );\n\n  useEffect(() => {\n    if (!socket) return;\n\n    const mergePlayerLog = (playerLog, patch) => {\n      playerLog = { ...playerLog, ...patch }; // Merge the changes\n      setPlayersLog(\n        playersLog.map(log => {\n          if (log.id === playerLog.id) return playerLog;\n          else return log;\n        })\n      );\n    };\n\n    // Saves in the context the player position in the story\n    socket.on('update:position', data => {\n      const { story, senderId, payload } = data;\n      if (story === storyId) {\n        let playerLog = playersLog.find(player => player.id === senderId);\n        if (playerLog) mergePlayerLog(playerLog, payload);\n      }\n    });\n\n    // Saves in the context the player responses and changes to the story's components\n    socket.on('update:stats', data => {\n      const { story, senderId, payload } = data;\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === senderId);\n        if (playerLog) {\n          // There's a new ending evaluation for that player\n          const { name, id } = playerLog;\n          if (playerLog.pendingEvaluation.length < payload.pendingEvaluation.length)\n            pushNotification(`New evaluation requested by ${name || id}`);\n          mergePlayerLog(playerLog, payload);\n        }\n      }\n    });\n\n    socket.on('chat-msg-recv', data => {\n      const { story, senderId, receiverId, msg } = data;\n      if (story === storyId) {\n        const playerId = senderId === `evaluator${storyId}` ? receiverId : senderId;\n        const playerLog = playersLog.find(player => player.id === playerId);\n        if (playerLog) {\n          const toSave = { sender: senderId, content: msg };\n          playerLog.chatLog = [...playerLog.chatLog, toSave];\n          // Maybe updatePlayerLog\n          if (senderId !== `evaluator${storyId}`) {\n            pushNotification(`New message from ${playerLog.name || playerLog.id}`);\n            playerLog.unreadMessages++;\n          }\n          mergePlayerLog(playerLog, playerLog);\n        }\n      }\n    });\n\n    socket.on('update:eval', data => {\n      const { story, playerId, newLog } = data;\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === playerId);\n        if (playerLog) mergePlayerLog(playerLog, newLog);\n      }\n    });\n\n    socket.on('add:player', data => {\n      const { story, payload } = data;\n      if (story === storyId) setPlayersLog([...playersLog, payload]);\n    });\n\n    socket.on('get:log', data => {\n      const { story, payload } = data;\n      if (story === storyId && payload) {\n        setPlayersLog(payload);\n        setFocusedPlayer((payload[0] || {}).id);\n      }\n    });\n\n    socket.on('rm:player', data => {\n      const { story, playerId } = data;\n      if (story === storyId) {\n        const playerLog = playersLog.find(player => player.id === playerId);\n        if (playerLog) {\n          playerLog.isDisconnected = true;\n          mergePlayerLog(playerLog, playerLog);\n        }\n      }\n    });\n\n    // This has to be checked\n    return () => socket.removeAllListeners();\n  }, [socket, playersLog, storyId, pushNotification]);\n\n  if (!loadedStory) {\n    return <Typography>Loading...</Typography>;\n  }\n\n  const toProvide = {\n    story,\n    storyId,\n    playersLog,\n    pushNotification,\n    selectedPlayer: playersLog.find(player => player.id === focusedPlayer),\n    setFocusedPlayer,\n    updatePlayerLog,\n    socket,\n  };\n\n  return (\n    <EvaluatorContext.Provider value={toProvide}>{children}</EvaluatorContext.Provider>\n  );\n};\n\nexport const useEvaluator = () => {\n  const value = useContext(EvaluatorContext);\n  if (value == null) {\n    throw new Error('useEvaluator must be used inside an EvaluatorProvider');\n  }\n\n  return value;\n};\n"]},"metadata":{},"sourceType":"module"}